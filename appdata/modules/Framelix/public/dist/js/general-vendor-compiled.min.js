'use strict';
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class FormDataJson {
  static toJson(el, options) {
    options = FormDataJson.merge(FormDataJson.defaultOptionsToJson, options);
    function isValidInput(input) {
      if (typeof options.inputFilter === 'function' && options.inputFilter(input) !== true) {
        return false;
      }
      if (!options.includeDisabled && input.disabled) {
        return false;
      }
      const inputType = (input.type || 'text').toLowerCase();
      if (!options.includeButtonValues && (input instanceof HTMLButtonElement || FormDataJson.buttonInputTypes.indexOf(inputType) > -1)) {
        return false;
      }
      if (typeof options.uncheckedValue === 'undefined' && FormDataJson.checkedInputTypes.indexOf(inputType) > -1 && !input.checked) {
        return false;
      }
      return true;
    }
    const tree = FormDataJson.getFieldTree(el, isValidInput);
    let returnObject = options.flatList ? [] : {};
    const files = [];
    function recursion(inputs, values) {
      for (let key in inputs) {
        const row = inputs[key];
        const objectKey = options.flatList ? row.name : key;
        if (row.type === 'nested') {
          if (options.flatList) {
            recursion(row.tree, values);
          } else {
            values[key] = {};
            recursion(row.tree, values[key]);
          }
          continue;
        }
        const input = row.input;
        const inputType = row.inputType;
        if (inputType === 'file') {
          if (options.filesCallback) {
            files.push({
              'object': values,
              'key': objectKey,
              'input': input
            });
          }
          continue;
        }
        let value = null;
        if (row.type === 'radio') {
          for (let i = 0; i < row.inputs.length; i++) {
            const radioInput = row.inputs[i];
            if (radioInput.checked) {
              value = radioInput.value;
              break;
            }
          }
          if (value === null) {
            value = options.uncheckedValue;
          }
        } else if (inputType === 'checkbox') {
          value = input.checked ? input.value : options.uncheckedValue;
        } else if (input instanceof HTMLSelectElement) {
          let arr = [];
          for (let i = 0; i < input.options.length; i++) {
            let option = input.options[i];
            if (option.selected) {
              arr.push((typeof option.value !== 'undefined' ? option.value : option.text).toString());
            }
          }
          if (input.multiple) {
            value = arr;
          } else {
            value = arr.length ? arr[0] : null;
          }
        } else {
          value = input.value;
        }
        if (options.flatList) {
          values.push([row.name, value]);
        } else {
          values[objectKey] = value;
        }
      }
    }
    function arrayify(object) {
      if (FormDataJson.isObject(object)) {
        let count = 0;
        let valid = true;
        for (let key in object) {
          if (FormDataJson.isObject(object[key]) && !(object[key] instanceof Element)) {
            object[key] = arrayify(object[key]);
          }
          if (parseInt(key) !== count) {
            valid = false;
          }
          count++;
        }
        if (valid) {
          let arr = [];
          for (let i in object) {
            arr.push(object[i]);
          }
          return arr;
        }
      }
      return object;
    }
    function output() {
      if (options.arrayify) {
        returnObject = arrayify(returnObject);
      }
      if (options.skipEmpty) returnObject = removeEmpty(returnObject) || (options.flatList ? [] : {});
      return returnObject;
    }
    function removeEmpty(object, depth) {
      const isArray = FormDataJson.isArray(object);
      let newObject = isArray ? [] : {};
      let count = 0;
      for (let key in object) {
        let value = object[key];
        if (options.flatList && !depth) {
          value = value[1];
        }
        if (FormDataJson.isObject(value) || FormDataJson.isArray(value)) {
          value = removeEmpty(value, (depth || 0) + 1) || '';
        }
        if (typeof value !== 'object' && FormDataJson.stringify(value) === '') {
          continue;
        }
        if (isArray) {
          newObject.push(object[key]);
        } else {
          newObject[key] = value;
        }
        count++;
      }
      return count ? newObject : null;
    }
    recursion(tree, returnObject);
    if (files.length) {
      let filesDone = 0;
      let filesRequired = 0;
      for (let i = 0; i < files.length; i++) {
        let row = files[i];
        let useObject = row.object;
        filesRequired += row.input.files.length;
        for (let j = 0; j < row.input.files.length; j++) {
          let file = row.input.files[j];
          let reader = new FileReader();
          reader.onload = function () {
            if (row.input.multiple) {
              if (!FormDataJson.isArray(useObject[row.key])) {
                useObject[row.key] = [];
              }
              useObject[row.key].push(reader.result);
            } else {
              useObject[row.key] = reader.result;
            }
            filesDone++;
            if (filesDone === filesRequired) {
              options.filesCallback(output());
            }
          };
          reader[options.fileReaderFunction](file);
        }
      }
    } else if (options.filesCallback) {
      options.filesCallback(output());
      return null;
    }
    return output();
  }
  static fromJson(el, values, options, keyPrefix) {
    if (!FormDataJson.isObject(values) && !FormDataJson.isArray(values)) return;
    options = FormDataJson.merge(FormDataJson.defaultOptionsFromJson, options);
    const tree = FormDataJson.getFieldTree(el);
    const lastUsedFlatListIndex = {};
    if (options.clearOthers) {
      FormDataJson.clear(el);
    }
    if (options.resetOthers) {
      FormDataJson.reset(el);
    }
    function recursion(inputs, newValues) {
      if (!FormDataJson.isObject(newValues) && !FormDataJson.isArray(newValues)) return;
      for (let key in inputs) {
        const row = inputs[key];
        const objectKey = options.flatList ? row.name : key;
        if (row.type === 'nested') {
          if (options.flatList) {
            recursion(row.tree, newValues);
          } else if (typeof newValues[objectKey] === 'object') {
            recursion(row.tree, newValues[objectKey]);
          }
          continue;
        }
        if (options.flatList) {
          for (let i in newValues) {
            const value = newValues[i];
            if (value && value[0] === row.name) {
              if (lastUsedFlatListIndex[row.name] !== i) {
                lastUsedFlatListIndex[row.name] = i;
                FormDataJson.setInputValue(row, value[1], options.triggerChangeEvent);
                break;
              }
            }
          }
          continue;
        }
        if (typeof newValues[objectKey] === 'undefined') {
          continue;
        }
        FormDataJson.setInputValue(row, newValues[objectKey] || null, options.triggerChangeEvent);
      }
    }
    recursion(tree, values);
  }
  static reset(el) {
    const tree = FormDataJson.getFieldTree(el);
    function recursion(inputs) {
      for (let key in inputs) {
        const row = inputs[key];
        if (row.type === 'nested') {
          recursion(row.tree);
          continue;
        }
        if (row.type === 'radio') {
          for (let i = 0; i < row.inputs.length; i++) {
            const radioInput = row.inputs[i];
            radioInput.checked = radioInput.defaultChecked;
          }
          continue;
        }
        if (row.inputType && FormDataJson.buttonInputTypes.indexOf(row.inputType) > -1) {
          continue;
        }
        const input = row.input;
        if (FormDataJson.checkedInputTypes.indexOf(row.inputType) > -1) {
          input.checked = input.defaultChecked;
        } else if (input instanceof HTMLSelectElement) {
          const options = input.querySelectorAll('option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            option.selected = option.defaultSelected;
          }
        } else if (input.getAttribute('value')) {
          input.value = input.getAttribute('value');
        } else if (typeof input.defaultValue === 'string' || typeof input.defaultValue === 'number') {
          input.value = input.defaultValue;
        }
      }
    }
    recursion(tree);
  }
  static clear(el) {
    const tree = FormDataJson.getFieldTree(el);
    function recursion(inputs) {
      for (let key in inputs) {
        const row = inputs[key];
        if (row.type === 'nested') {
          recursion(row.tree);
          continue;
        }
        if (row.input) {
          if (FormDataJson.buttonInputTypes.indexOf(row.inputType) > -1) {
            continue;
          }
        }
        FormDataJson.setInputValue(row, null);
      }
    }
    recursion(tree);
  }
  static setInputValue(row, newValue, triggerChangeEvent) {
    const triggerChange = triggerChangeEvent ? function (el) {
      let ev = null;
      if (typeof Event === 'function') {
        ev = new Event('change', {
          'bubbles': true
        });
      } else {
        ev = document.createEvent('Event');
        ev.initEvent('change', true, true);
      }
      el.dispatchEvent(ev);
    } : null;
    if (row.type === 'radio') {
      let changed = [];
      for (let i = 0; i < row.inputs.length; i++) {
        const radioInput = row.inputs[i];
        if (radioInput.checked) changed.push(radioInput);
        radioInput.checked = false;
        if (newValue !== null && FormDataJson.stringify(radioInput.value) === FormDataJson.stringify(newValue)) {
          if (!radioInput.checked) changed.push(radioInput);
          radioInput.checked = true;
          break;
        }
      }
      if (triggerChange) {
        for (let i in changed) {
          triggerChange(changed[i]);
        }
      }
      return;
    }
    const input = row.input;
    const inputType = row.inputType;
    if (inputType === 'file') {
      return;
    }
    let changed = false;
    if (inputType === 'checkbox') {
      newValue = newValue === true || newValue !== null && FormDataJson.stringify(input.value) === FormDataJson.stringify(newValue);
      if (newValue !== input.checked) changed = true;
      input.checked = newValue;
    } else if (input instanceof HTMLSelectElement) {
      let newValueArr = newValue;
      if (newValueArr === null || newValueArr === undefined) {
        newValueArr = [];
      } else if (FormDataJson.isObject(newValueArr)) {
        newValueArr = Object.values(newValueArr);
      } else if (!FormDataJson.isArray(newValueArr)) {
        newValueArr = [newValueArr];
      }
      for (let i = 0; i < input.options.length; i++) {
        const option = input.options[i];
        const optionValue = (typeof option.value !== 'undefined' ? option.value : option.text).toString();
        if (option.selected !== false) changed = true;
        option.selected = false;
        for (let j = 0; j < newValueArr.length; j++) {
          if (optionValue === FormDataJson.stringify(newValueArr[j])) {
            if (option.selected !== true) changed = true;
            option.selected = true;
            break;
          }
        }
      }
    } else {
      if (input.value !== newValue) changed = true;
      input.value = newValue;
    }
    if (changed && triggerChange) {
      triggerChange(input);
    }
  }
  static stringify(value) {
    if (value === undefined) return '';
    if (typeof value === 'object') return '';
    if (typeof value === 'boolean') return value ? '1' : '0';
    return value + '';
  }
  static getFieldTree(el, isValidInput) {
    el = FormDataJson.getElement(el);
    if (!el) {
      return [];
    }
    let inputs = el.querySelectorAll('select, textarea, input, button');
    let inputTree = {};
    let autoIncrementCounts = {};
    for (let i = 0; i < inputs.length; i++) {
      const input = inputs[i];
      if (!input.name || input.name.length === 0) continue;
      if (isValidInput && isValidInput(input) !== true) continue;
      const inputType = (input.type || 'text').toLowerCase();
      let name = input.name;
      const keyParts = input.name.replace(/\]/g, '').split('[');
      if (name.substr(-2) === '[]') {
        if (input instanceof HTMLSelectElement && input.multiple) {
          keyParts.pop();
        } else if (inputType === 'radio') {
          keyParts.pop();
        }
      }
      const keyPartsLength = keyParts.length;
      let useObject = inputTree;
      let currentName = '';
      for (let j = 0; j < keyPartsLength; j++) {
        let keyPart = keyParts[j];
        let newCurrentName = currentName ? currentName + '[' + keyPart + ']' : keyPart;
        if (keyPart === '') {
          if (typeof autoIncrementCounts[newCurrentName] === 'undefined') {
            autoIncrementCounts[newCurrentName] = 0;
          }
          keyPart = autoIncrementCounts[newCurrentName].toString();
          autoIncrementCounts[newCurrentName]++;
        }
        currentName = currentName ? currentName + '[' + keyPart + ']' : keyPart;
        if (keyPartsLength - 1 === j) {
          if ((input.type || 'text').toLowerCase() === 'radio') {
            if (typeof useObject[keyPart] === 'undefined') {
              useObject[keyPart] = {
                'type': 'radio',
                'name': input.name,
                'inputType': inputType,
                'inputs': []
              };
            }
            useObject[keyPart].inputs.push(input);
          } else {
            useObject[keyPart] = {
              'type': 'default',
              'name': input.name,
              'inputType': inputType,
              'input': input
            };
          }
        } else {
          if (typeof useObject[keyPart] === 'undefined' || typeof useObject[keyPart].tree === 'undefined') {
            useObject[keyPart] = {
              'type': 'nested',
              'tree': {}
            };
          }
          useObject = useObject[keyPart].tree;
        }
      }
    }
    return inputTree;
  }
  static isObject(arg) {
    return arg && typeof arg === 'object' && Object.prototype.toString.call(arg) !== '[object Array]';
  }
  static isArray(arg) {
    return typeof arg === 'object' && Object.prototype.toString.call(arg) === '[object Array]';
  }
  static getElement(param) {
    if (typeof param === 'string') return document.querySelector(param);
    if (param instanceof HTMLElement) return param;
    if (typeof jQuery !== 'undefined' && param instanceof jQuery) return param[0];
    if (typeof $ !== 'undefined' && param instanceof $) return param[0];
    console.warn('FormDataJson: Unsupported element passed. Supported is HTMLElement, a string query selector, JQuery or $ object');
    return null;
  }
  static merge(a, b) {
    let c = {};
    for (let key in a) {
      c[key] = a[key];
    }
    for (let key in b) {
      c[key] = b[key];
    }
    return c;
  }
}
_defineProperty(FormDataJson, "defaultOptionsToJson", {
  'includeDisabled': false,
  'includeButtonValues': false,
  'uncheckedValue': undefined,
  'inputFilter': null,
  'flatList': false,
  'skipEmpty': false,
  'filesCallback': null,
  'fileReaderFunction': 'readAsDataURL',
  'arrayify': true
});
_defineProperty(FormDataJson, "defaultOptionsFromJson", {
  'flatList': false,
  'clearOthers': false,
  'resetOthers': false,
  'triggerChangeEvent': false
});
_defineProperty(FormDataJson, "buttonInputTypes", ['button', 'submit', 'reset', 'image']);
_defineProperty(FormDataJson, "checkedInputTypes", ['checkbox', 'radio']);
if (typeof module !== 'undefined' && module.exports) {
  module.exports = FormDataJson;
}